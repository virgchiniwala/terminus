use crate::providers::types::{ProviderError, ProviderRequest, ProviderResponse, ProviderUsage};
use crate::transport::ExecutionTransport;
use std::collections::HashMap;
use std::sync::Mutex;

pub struct MockTransport {
    attempts: Mutex<HashMap<String, u32>>,
}

impl MockTransport {
    pub fn new() -> Self {
        Self {
            attempts: Mutex::new(HashMap::new()),
        }
    }

    fn key_for(request: &ProviderRequest) -> String {
        request
            .correlation_id
            .clone()
            .unwrap_or_else(|| request.input.clone())
    }

    fn usage_for(request: &ProviderRequest) -> ProviderUsage {
        let estimated_cost_usd_cents = if request.input.contains("simulate_cap_hard") {
            95
        } else if request.input.contains("simulate_cap_soft") {
            45
        } else if request.input.contains("simulate_cap_boundary") {
            80
        } else {
            12
        };

        ProviderUsage {
            input_tokens: 320,
            output_tokens: 140,
            estimated_cost_usd_cents,
        }
    }
}

impl ExecutionTransport for MockTransport {
    fn dispatch(
        &self,
        request: &ProviderRequest,
        _keychain_api_key: Option<&str>,
    ) -> Result<ProviderResponse, ProviderError> {
        if request
            .correlation_id
            .as_deref()
            .is_some_and(|id| id.starts_with("plan_gen:"))
        {
            let lower = request.input.to_ascii_lowercase();
            let text = if lower.contains("api ")
                || lower.contains("http api")
                || lower.contains("crm")
            {
                r#"{"steps":[{"id":"step_1","label":"Call CRM API","primitive":"call_api","requires_approval":true,"risk_tier":"high"},{"id":"step_2","label":"Prepare outcome","primitive":"write_outcome_draft","requires_approval":true,"risk_tier":"medium"}],"web_allowed_domains":["api.example.com"],"recipient_hints":[],"allowed_primitives":["call_api","write_outcome_draft"],"api_call_request":{"url":"https://api.example.com/v1/items","method":"GET","header_key_ref":"crm_prod","auth_header_name":"Authorization","auth_scheme":"bearer","body_json":null}}"#
                    .to_string()
            } else if lower.contains("invoice") || lower.contains("receipt") {
                r#"{"steps":[{"id":"step_1","label":"Read forwarded invoice text","primitive":"read_forwarded_email","requires_approval":false,"risk_tier":"low"},{"id":"step_2","label":"Summarize extracted categories into an outcome","primitive":"write_outcome_draft","requires_approval":true,"risk_tier":"medium"}],"web_allowed_domains":[],"recipient_hints":[],"allowed_primitives":["read_forwarded_email","write_outcome_draft"]}"#
                    .to_string()
            } else {
                r#"{"steps":[{"id":"step_1","label":"Read configured sources","primitive":"read_sources","requires_approval":false,"risk_tier":"low"},{"id":"step_2","label":"Aggregate summary","primitive":"aggregate_daily_summary","requires_approval":false,"risk_tier":"medium"},{"id":"step_3","label":"Prepare outcome","primitive":"write_outcome_draft","requires_approval":true,"risk_tier":"medium"}],"web_allowed_domains":[],"recipient_hints":[],"allowed_primitives":["read_sources","aggregate_daily_summary","write_outcome_draft"]}"#
                    .to_string()
            };

            return Ok(ProviderResponse {
                provider_kind: request.provider_kind,
                provider_tier: request.provider_tier,
                model: request.model.clone(),
                text,
                usage: Self::usage_for(request),
            });
        }

        if request
            .input
            .contains("simulate_provider_non_retryable_failure")
        {
            return Err(ProviderError::non_retryable(
                "Provider rejected the request. Update the prompt and try again.",
            ));
        }

        if request
            .input
            .contains("simulate_provider_retryable_failure")
        {
            let key = Self::key_for(request);
            let mut attempts = self
                .attempts
                .lock()
                .map_err(|_| ProviderError::non_retryable("Transport state is unavailable."))?;
            let attempt = attempts.entry(key).or_insert(0);
            if *attempt == 0 {
                *attempt += 1;
                return Err(ProviderError::retryable(
                    "Provider is temporarily unavailable.",
                ));
            }
        }

        Ok(ProviderResponse {
            provider_kind: request.provider_kind,
            provider_tier: request.provider_tier,
            model: request.model.clone(),
            text: format!(
                "Draft generated by {} ({})",
                request.provider_kind.as_str(),
                request.model
            ),
            usage: Self::usage_for(request),
        })
    }
}
