use crate::providers::types::{ProviderError, ProviderRequest, ProviderResponse, ProviderUsage};
use crate::transport::ExecutionTransport;
use std::collections::HashMap;
use std::sync::Mutex;

pub struct MockTransport {
    attempts: Mutex<HashMap<String, u32>>,
}

impl MockTransport {
    pub fn new() -> Self {
        Self {
            attempts: Mutex::new(HashMap::new()),
        }
    }

    fn key_for(request: &ProviderRequest) -> String {
        request
            .correlation_id
            .clone()
            .unwrap_or_else(|| request.input.clone())
    }

    fn usage_for(request: &ProviderRequest) -> ProviderUsage {
        let estimated_cost_usd_cents = if request.input.contains("simulate_cap_hard") {
            95
        } else if request.input.contains("simulate_cap_soft") {
            45
        } else if request.input.contains("simulate_cap_boundary") {
            80
        } else {
            12
        };

        ProviderUsage {
            input_tokens: 320,
            output_tokens: 140,
            estimated_cost_usd_cents,
        }
    }
}

impl ExecutionTransport for MockTransport {
    fn dispatch(
        &self,
        request: &ProviderRequest,
        _keychain_api_key: Option<&str>,
    ) -> Result<ProviderResponse, ProviderError> {
        if request
            .input
            .contains("simulate_provider_non_retryable_failure")
        {
            return Err(ProviderError::non_retryable(
                "Provider rejected the request. Update the prompt and try again.",
            ));
        }

        if request
            .input
            .contains("simulate_provider_retryable_failure")
        {
            let key = Self::key_for(request);
            let mut attempts = self
                .attempts
                .lock()
                .map_err(|_| ProviderError::non_retryable("Transport state is unavailable."))?;
            let attempt = attempts.entry(key).or_insert(0);
            if *attempt == 0 {
                *attempt += 1;
                return Err(ProviderError::retryable(
                    "Provider is temporarily unavailable.",
                ));
            }
        }

        Ok(ProviderResponse {
            provider_kind: request.provider_kind,
            provider_tier: request.provider_tier,
            model: request.model.clone(),
            text: format!(
                "Draft generated by {} ({})",
                request.provider_kind.as_str(),
                request.model
            ),
            usage: Self::usage_for(request),
        })
    }
}
